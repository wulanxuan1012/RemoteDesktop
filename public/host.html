<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>è¿œç¨‹æ¡Œé¢ - å±å¹•å…±äº«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        p {
            color: #888;
            margin-bottom: 30px;
        }

        #status {
            padding: 10px 20px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }

        #status.connected {
            background: rgba(46, 213, 115, 0.2);
            color: #2ed573;
        }

        #status.sharing {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        button {
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #preview {
            margin-top: 30px;
            max-width: 600px;
            width: 100%;
            border-radius: 10px;
            background: #000;
        }

        .viewers {
            margin-top: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <h1>ğŸ–¥ï¸ è¿œç¨‹æ¡Œé¢ - ä¸»æœºç«¯</h1>
    <p>åœ¨æ­¤ç”µè„‘ä¸Šå¼€å§‹å±å¹•å…±äº«</p>

    <div id="status">æœªè¿æ¥</div>

    <button id="startBtn" disabled>å¼€å§‹å…±äº«</button>

    <video id="preview" autoplay muted playsinline></video>

    <div class="viewers">
        <span>ğŸ‘¥ è¿æ¥çš„è§‚çœ‹è€…: </span><span id="viewerCount">0</span>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const preview = document.getElementById('preview');
        const viewerCountEl = document.getElementById('viewerCount');

        let ws = null;
        let localStream = null;
        const peerConnections = new Map(); // viewerId -> RTCPeerConnection

        // è¿æ¥ WebSocket
        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}`);

            ws.onopen = () => {
                statusEl.textContent = 'å·²è¿æ¥æœåŠ¡å™¨';
                statusEl.className = 'connected';
                startBtn.disabled = false;

                // æ³¨å†Œä¸ºä¸»æœº
                ws.send(JSON.stringify({ type: 'register-host' }));
            };

            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                await handleMessage(message);
            };

            ws.onclose = () => {
                statusEl.textContent = 'è¿æ¥æ–­å¼€ï¼Œé‡è¿ä¸­...';
                statusEl.className = '';
                startBtn.disabled = true;
                setTimeout(connect, 3000);
            };
        }

        async function handleMessage(message) {
            switch (message.type) {
                case 'registered':
                    console.log('å·²æ³¨å†Œä¸ºä¸»æœº');
                    break;

                case 'offer':
                    console.log('æ”¶åˆ° Offer from viewer:', message.viewerId);
                    await handleOffer(message.viewerId, message.sdp);
                    break;

                case 'ice-candidate':
                    const pc = peerConnections.get(message.viewerId);
                    if (pc && message.candidate) {
                        await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
                    }
                    break;
            }
        }

        async function handleOffer(viewerId, sdp) {
            console.log(`[handleOffer] viewerId=${viewerId}, localStream=${!!localStream}`);

            if (!localStream) {
                console.warn('æ²¡æœ‰åª’ä½“æµ');
                return;
            }

            console.log(`[handleOffer] localStream tracks:`, localStream.getTracks().map(t => ({ kind: t.kind, enabled: t.enabled, readyState: t.readyState })));

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnections.set(viewerId, pc);
            viewerCountEl.textContent = peerConnections.size;

            // æ·»åŠ æœ¬åœ°æµ
            localStream.getTracks().forEach(track => {
                console.log(`[handleOffer] Adding track: ${track.kind}, enabled=${track.enabled}`);
                pc.addTrack(track, localStream);
            });

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        viewerId
                    }));
                }
            };

            pc.onnegotiationneeded = () => {
                console.log('[handleOffer] Negotiation needed');
            };

            pc.onconnectionstatechange = () => {
                console.log(`Viewer ${viewerId} çŠ¶æ€:`, pc.connectionState);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    peerConnections.delete(viewerId);
                    viewerCountEl.textContent = peerConnections.size;
                }
            };

            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            console.log('[handleOffer] Answer SDP preview:', answer.sdp.substring(0, 200));

            ws.send(JSON.stringify({
                type: 'answer',
                sdp: answer.sdp,
                viewerId
            }));

            console.log('å·²å‘é€ Answer to viewer:', viewerId);
        }

        // å¼€å§‹å…±äº«
        startBtn.onclick = async () => {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 60 }
                    },
                    audio: false
                });

                preview.srcObject = localStream;
                statusEl.textContent = 'æ­£åœ¨å…±äº«å±å¹•...';
                statusEl.className = 'sharing';
                startBtn.textContent = 'å…±äº«ä¸­...';
                startBtn.disabled = true;

                // ç›‘å¬åœæ­¢å…±äº«
                localStream.getVideoTracks()[0].onended = () => {
                    statusEl.textContent = 'å…±äº«å·²åœæ­¢';
                    statusEl.className = 'connected';
                    startBtn.textContent = 'å¼€å§‹å…±äº«';
                    startBtn.disabled = false;
                    localStream = null;

                    // å…³é—­æ‰€æœ‰è¿æ¥
                    peerConnections.forEach(pc => pc.close());
                    peerConnections.clear();
                    viewerCountEl.textContent = 0;
                };

            } catch (error) {
                console.error('å±å¹•å…±äº«å¤±è´¥:', error);
                alert('å±å¹•å…±äº«å¤±è´¥: ' + error.message);
            }
        };

        connect();
    </script>
</body>

</html>